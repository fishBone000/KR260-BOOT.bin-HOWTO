## Zynq KR260 Bare-Metal Firmware Upload

This article provides a method for generating BOOT.bin and uploading it to the KR260 development board for readers' reference. I am writing this because I encountered several pitfalls in this area; now that I have figured it out, I am sharing it to help others.

### Pitfalls I Encountered

The QSPI on the KR260 board comes with official default firmware, and the KR260 boots from this firmware. However, since this firmware is U-Boot, it does not load a bare-metal BOOT.bin when reading the SD card; instead, it looks for boot.scr.uimg used for Linux booting. Therefore, unless the QSPI contains an FSBL capable of reading the BOOT.bin from the SD card via the USB hub, simply copying BOOT.bin to the SD card will not correctly boot a bare-metal program.

Additionally, I noticed that the KR260's onboard SD card reader is connected to the board's USB hub. Consequently, the BOOT.bin inside the SD card cannot be read directly through the PS-side SD card peripheral. I hope this helps readers looking to explore SD card booting.

Furthermore, if you modify your design in Vivado and re-import the XSA file in Vitis 2025.2, some critical files will not update. For example, the bitstream and initialization TCL scripts under the _ide directory of all apps, as well as the workspace_root/platform/zynqmp_fsbl/psu_init.c within the FSBL of the hardware platform. This leads to an outdated FSBL initialization process generated by the BSP and an outdated TCL initialization script used during debugging. The psu_init.c issue in the FSBL can be resolved by re-importing the FSBL template (presumably every time you import an XSA). For the TCL initialization script issue, you can switch to FSBL initialization during debugging, or select the bitstream and initialization TCL script located under platform/export/hw/sdt/ in the debug launch settings.

Not done yet! Under some circumstances `RESET` button cannot reset the board entirely, replugin the DC power cable if necessary.
The effect of resets shall be: plug out & in DC power > `RESET` button > Vitis debug reset

Finally, the BOOT.bin generated by Vitis may have issues. If you encounter problems, consider regenerating or re-uploading the firmware. This is true—after generating a BOOT.bin with a custom FSBL and uploading it at the end of this article, one of the two serial ports failed to output. Regenerating a new copy fixed it. It is also possible that an error occurred during uploading, but given the CRC32 check, this possibility is not very high.

Environment: Vivado & Vitis 2025.2. Steps for other versions should be similar.

    My Vitis 2025.2 might differ from older versions in several ways: You need to set a workspace before starting a project; older versions might launch the SDK directly from Vivado without this step. "Platform Component" corresponds to the "Hardware" in older versions, which is the hardware imported from the XSA. "App Component" corresponds to the "App Project." The operations are basically the same as in older versions, though the UI differs.

    I am using 2025.2 because 2022 had severe, usability-impacting bugs on my OS; it is not necessarily the best version to use.

### Create Vivado Project and Export Hardware

A demonstration Vivado project is created here.

Create Block Design, and add a Zynq UltraScale+ MPSoC IP core. Click Run Block Automation at the top of the interface to apply the board's default settings to the Zynq IP core.

![image-20260107123402749](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107123402749.png)

Connect the two **pl_clk** signals on the right side of the IP core to the **maxihpmX_fpd_aclk** ports on the left side.
Double-click to enter the IP core settings and enable both UARTs. For UART1, select `MIO 36 .. 37`, and for UART0, select EMIO to route the output through the board's pins.

> The reason for selecting MIO 36 and 37 is that these two MIOs on the KR260 are connected to the onboard Micro-USB interface. This can be verified on the JTAG/UART page of the official schematic; simply search for MIO36 and MIO37 in the schematic PDF.

![image-20260107123605917](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107123605917.png)

Click OK to save the IP core settings. Export UART_0 on the right side of the IP core as an external interface (Make External).

Note that the default settings applied here enable QSPI, which is necessary. Later, the FSBL will communicate with the QSPI storage through the QSPI peripheral to load the bitstream and the application ELF.

Save the Block Design. Generate the HDL Wrapper.

Next, click Open Elaborated Design to set the pins for UART0. Select W13 for UART_0_0_rxd (corresponding to KR260 Raspberry Pi header PIN 10) and W14 for UART_0_0_txd (corresponding to Raspberry Pi header PIN 8). Select LVTTL for the I/O standard (LVCMOS33 also works, as they are the same). Looking at the KR260 Raspberry Pi header toward the fan, in the row further away, counting from left to right: the third pin is PIN 3 (GND), the fourth pin is PIN 8, and the fifth pin is PIN 10. Connect your PC's USB-to-TTL serial adapter to these three pins.

![image-20260107124940710](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107124940710.png)

Press **CTRL-S** to save as `io.xdc`. The filename does not matter.

Then, generate the bitstream. Export the XSA file, making sure to include the bitstream.

### Create Vitis Project and Generate BOOT.bin

Open Vitis and import the XSA file.

Modify the following options in the BSP (Board Support Package):

1. Change the **stdin** and **stdout** of the FSBL BSP to `psu_uart_1`.
2. Check and ensure the **stdin** and **stdout** of the application BSP are set to `psu_uart_1`.

![image-20260107125941165](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107125941165.png)

![image-20260107130048192](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107130048192.png)

The first step is actually not necessary, but adding it allows you to see the FSBL output on the serial port.

> In my testing, setting the FSBL's stdio to `None` (if any UART is enabled) causes macro errors during compilation. If you do not want to output FSBL information to the serial port, you can set it to `coresight` or manually modify the FSBL code (located under `platform/zynqmp_fsbl`).

Then, regenerate both BSPs. (This is because certain compilation configuration files do not update after modifying `stdio`, so the BSP must be regenerated. This limitation might only apply to the FSBL BSP, but to save time, it is better to regenerate the application BSP as well.)

![image-20260107130413857](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107130413857.png)

![image-20260107130456461](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107130456461.png)

Build the platform.

Create standalone (baremetal) application project.

Create main.c, code as follows:

```c
#include <xil_printf.h>
#include <sleep.h>
#include <xparameters.h>
#include <xuartps.h>

int main()
{
    xil_printf("main entry!\r\n");
    XUartPs uart;
    XUartPs_Config *pCfg = XUartPs_LookupConfig(XPAR_XUARTPS_0_BASEADDR);
    XUartPs_CfgInitialize(&uart, pCfg, pCfg->BaseAddress);
    u8 s[] = "Hello world!\r\n";
    while (1)
    {
        sleep(1);
        XUartPs_Send(&uart, s, sizeof(s));
    }
}
```

Then compile.

Generate the `BOOT.bin`. For the FSBL, select the FSBL you just compiled in the platform component; in Vitis 2025.2, this is selected by default. The path corresponds to: `workspace_root/platform/export/platform/sw/boot/fsbl.elf` (where "platform" is the name of your platform component).

By default, my bitstream was selected as `workspace_root/app_component/_ide/bitstream/design_1_wrapper.bit`. Since Vitis 2025.2 does not update this file after re-importing an XSA file, I recommend manually selecting `workspace_root/platform/export/platform/hw/sdt/design_1_wrapper.bit` instead.

Vitis 2025.2 does not pre-select a BIF output path, so just choose any directory for the output.

### Uploading the Firmware

Here is the important part!

After the Zynq UltraScale+ MPSoC powers on, the PMU/CSU firmware reads the BOOT MODE pins to determine the boot method. From the KR260 schematics, you can see that the pins are set to QSPI boot mode. This means the firmware will boot via QSPI.

The official QSPI contains default factory firmware. To prevent users from bricking the board, the official setting locks the QSPI, meaning users cannot directly overwrite the firmware. However, this QSPI firmware includes a built-in Boot Image Recovery Tool that allows users to upload a `BOOT.bin` to two image slots in the QSPI, labeled Image A and Image B. In other words, while you cannot write to the QSPI directly, you can write to two officially designated locations via the recovery tool. Below is the official wiki link:
[https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1641152513/Kria+SOMs+Starter+Kits#Boot-Image-Recovery-Tool](https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1641152513/Kria+SOMs+Starter+Kits#Boot-Image-Recovery-Tool)

We will use this recovery tool to upload the `BOOT.bin` we just generated.

First, connect the KR260 to your computer using an Ethernet cable. Use the bottom-right port of the four Ethernet ports on the KR260 (it must be this one). Set your computer's network to a static IP of `192.168.0.xxx` with a subnet mask of `255.255.255.0`. Note that it cannot be `192.168.0.111`, as that is the IP used by the KR260 recovery tool.

Next, connect the USB cable to your computer. Note that the KR260 side connects to the Micro-USB port. Since UART1 uses MIO 36 and 37, it routes through the onboard USB-to-UART bridge; therefore, the UART1 serial data is transmitted via the Micro-USB cable. Once connected, four new serial ports should appear on your computer. Open the second one, set the baud rate to 115200, and the format to 8N1. If you don't know what 8N1 is, you can skip that part as most serial tools default to 8N1. Simultaneously, open the serial port for UART0 with the same baud rate and format.

I recommend using software with terminal capabilities, such as PuTTY, to view the firmware output. Some firmware (like Image A on my board) outputs terminal control characters; if viewed with a tool that lacks terminal emulation, you might see a mess of garbled code. For reference, here is the Linux PuTTY command: `putty /dev/ttyUSB1 -serial -sercfg 115200,8,n,1,N`. However, since our FSBL does not output terminal sequences, using `cat` or a standard serial debugger is also fine.

Locate the `FWUEN` and `RESET` buttons on the KR260 board. The former is the Firmware Update Enable button, and the latter is the Reset button; both are located near the fan. While holding down the `FWUEN` button, short-press the `RESET` button. This triggers the official QSPI firmware to launch the Image Recovery Tool. You can release the `FWUEN` button after pressing `RESET`.

At this point, you should see the startup information for the Image Recovery Tool on the serial port. Whether you see this should be independent of our previous selection of UART1 and MIO 36–37.

![image-20260107132817703](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107132817703.png)

Then open your browser and visit the URL `http://192.168.0.111`. Note that you must include the `http` prefix; otherwise, the browser might attempt to access port 443 for HTTPS.

You should then be able to see the interface.

![image-20260107133008568](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107133008568.png)

Upload the newly generated `BOOT.bin` to **Image B** (Image B is recommended to avoid overwriting the default Image A), and then set the **Requested Boot Image** to Image B.

Next, short-press the `RESET` button to restart the development board.

You should now see brief FSBL messages on the serial port, followed by your application's `Hello World!` messages filling the screen!

![image-20260107133155469](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107133155469.png)

Since we previously set the stdio for both the FSBL and the application BSP to uart1, we can receive the xil_printf messages from both via the USB cable. In the application code, Hello World! is output using UART0, so those messages are received through the Raspberry Pi expansion pins. Furthermore, since UART0 uses EMIO—routing through the PL to the pins—this confirms that our PL has also been successfully configured!
Custom FSBL

Vitis allows you to import an FSBL template, which means we have better control over the FSBL, such as adding debug information or even modifying the code. Additionally, since importing an XSA does not update workspace_root/platform/zynqmp_fsbl/psu_init.c, importing an FSBL template serves as a workaround for this issue.

This section is not strictly necessary, but it is recommended.

![image-20260108003110427](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260108003110427.png)

Import the ZynqMP FSBL template in Vitis. The tool might prompt you that the application's domain (essentially the BSP) does not meet the requirements for the FSBL template. In this case, create a new domain and name it fsbl_domain. Ensure that you select psu_cortexa53_0 as the Processor (it defaults to 2).

![image-20260107133845379](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107133845379.png)

Modify the stdio settings for the BSP under fsbl_domain to UART1.

![image-20260107134034367](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107134034367.png)

Compile the platform.

Add the `FSBL_DEBUG_DETAILED` symbol to the compilation options of the `zynqmp_fsbl` component you just created. This macro definition can be found in `xfsbl_debug.h`; once enabled, the FSBL will output at maximum verbosity.

Then, compile the FSBL.

Return to the application you created at the beginning and regenerate the boot image. Note that for the FSBL, you must select `workspace_root/zynqmp_fsbl/build/zynqmp_fsbl.elf`. Pay close attention to the path! When importing the XSA, a `zynqmp_fsbl` is also generated at `workspace_root/platform/zynqmp_fsbl/`, but that is **not** the one we are using here.

Next, upload the firmware using the same steps with the Image Recovery Tool as described above. Note that `Select Image to be recovered` may automatically default back to `Image A` (since we previously uploaded to B); I selected `B` again to avoid overwriting the default `Image A`.

Then, short-press the `RESET` button to restart the development board.

You will now see detailed FSBL output along with your application's `Hello World!` output!

![image-20260107141007173](https://github.com/fishBone000/KR260-BOOT.bin-HOWTO/blob/main/image-20260107141007173.png)
